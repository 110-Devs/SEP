/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/lib/truncate/filter.ts":
/*!************************************!*\
  !*** ./src/lib/truncate/filter.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst domJSON = __importStar(__webpack_require__(/*! ../truncate/domJSON */ \"./src/lib/truncate/domJSON.js\"));\r\nconsole.log(\"Hello World\");\r\nconst rawDomJSON = domJSON.createDomJSON();\r\nconst myDiv = rawDomJSON.toJSON(document.body, {\r\n    attributes: {\r\n        values: ['name', 'class', 'id', 'data-selector']\r\n    },\r\n    domProperties: {\r\n        values: []\r\n    }\r\n});\r\nexports[\"default\"] = myDiv;\r\n\n\n//# sourceURL=webpack:///./src/lib/truncate/filter.ts?");

/***/ }),

/***/ "./src/lib/truncate/domJSON.js":
/*!*************************************!*\
  !*** ./src/lib/truncate/domJSON.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createDomJSON\": () => (/* binding */ createDomJSON)\n/* harmony export */ });\n/* harmony import */ var _medv_finder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @medv/finder */ \"../../../node_modules/@medv/finder/finder.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\r\n\r\n/**\r\n * domJSON.js: A simple framework for converting DOM nodes to special JSON objects, and vice versa\r\n * The finder library is used in in the attrJSON() method. Further explanation there. \r\n * \r\n * WIP: Converting to a TypeScript-file\r\n *\r\n * @fileOverview\r\n * @author  Alex Zaslavsky\r\n * @version 0.1.2\r\n * @license The MIT License: Copyright (c) 2013 Alex Zaslavsky\r\n */\r\n\r\nfunction createDomJSON(win) {\r\n    \"use strict\";\r\n  \r\n    /**\r\n     * domJSON is a global variable to store two methods: `.toJSON()` to convert a DOM Node into a JSON object, and `.toDOM()` to turn that JSON object back into a DOM Node\r\n     * @namespace domJSON\r\n     * @global\r\n     */\r\n    var domJSON = {};\r\n  \r\n    /**\r\n     * An object specifying a list of fields and how to filter it, or an array with the first value being an optional boolean to convey the same information\r\n     * @typedef {Object|Array} FilterList\r\n     * @property {boolean} [exclude=false] If this is set to `true`, the `filter` property will specify which fields to exclude from the result (boolean difference), not which ones to include (boolean intersection)\r\n     * @property {string[]} values An array of strings which specify the fields to include/exclude from some broader list\r\n     */\r\n  \r\n    /**\r\n     * Default metadata for a JSON object\r\n     * @private\r\n     * @ignore\r\n     */\r\n  /*  var metadata = {\r\n      href: win.location.href || null,\r\n      userAgent:\r\n        window.navigator && window.navigator.userAgent\r\n          ? window.navigator.userAgent\r\n          : null,\r\n      version: \"0.1.2\",\r\n    };\r\n  */\r\n    /**\r\n     * Default options for creating the JSON object\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var defaultsForToJSON = {\r\n      absolutePaths: [\"action\", \"data\", \"href\", \"src\"],\r\n      //absStylePaths: ['attr', 'background', 'background-image', 'border-image', 'border-image-source', 'content', 'list-style-image', 'mask-image'], //http://stackoverflow.com/questions/27790925/what-are-all-the-css3-properties-that-accept-urls-or-uris\r\n      attributes: true,\r\n      computedStyle: false,\r\n      cull: true,\r\n      deep: true,\r\n      domProperties: true,\r\n      filter: false,\r\n      htmlOnly: false,\r\n      metadata: false,\r\n      //parse: false,\r\n      serialProperties: false,\r\n      stringify: false,\r\n      allowDangerousElements: false,\r\n    };\r\n  \r\n    /**\r\n     * Default options for creating a DOM node from a previously generated domJSON object\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var defaultsForToDOM = {\r\n      noMeta: false,\r\n      allowDangerousElements: false,\r\n    };\r\n  \r\n    /**\r\n     * A list of disallowed HTMLElement tags - there is no flexibility here, these cannot be processed by domJSON for security reasons!\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var banned = [\"link\", \"script\"]; //Consider (maybe) adding the following tags: iframe, html, audio, video, object\r\n  \r\n    /**\r\n     * A list of node properties that must be copied if they exist; there is no user option that will remove these\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var required = [\"nodeType\", \"nodeValue\", \"tagName\"];\r\n  \r\n    /**\r\n     * A list of node properties to specifically avoid simply copying; there is no user option that will allow these to be copied directly\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var ignored = [\r\n      \"attributes\",\r\n      \"childNodes\",\r\n      \"children\",\r\n      \"classList\",\r\n      \"dataset\",\r\n      \"style\",\r\n    ];\r\n  \r\n    /**\r\n     * A list of serialized read-only nodes to ignore; these can ovewritten if the user specifies the \"filter\" option\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var serials = [\r\n      \"innerHTML\",\r\n      \"innerText\",\r\n      \"outerHTML\",\r\n      \"outerText\",\r\n      \"prefix\",\r\n      \"text\",\r\n      \"textContent\",\r\n      \"wholeText\",\r\n    ];\r\n  \r\n    /**\r\n     * Utility function to extend an object - useful for synchronizing user-submitted options with default values; same API as underscore extend\r\n     * @param {Object} [target] The object that will be extended\r\n     * @param {...Object} [added] Additional objects that will extend the target\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var extend = function (target) {\r\n      if (!arguments.length) {\r\n        return arguments[0] || {};\r\n      }\r\n  \r\n      //Overwrite matching properties on the target from the added object\r\n      for (var p in arguments[1]) {\r\n        target[p] = arguments[1][p];\r\n      }\r\n  \r\n      //If we have more arguments, run the function recursively\r\n      if (arguments.length > 2) {\r\n        var moreArgs = [target].concat(Array.prototype.slice.call(arguments, 2));\r\n        return extend.apply(null, moreArgs);\r\n      } else {\r\n        return target;\r\n      }\r\n    };\r\n  \r\n    /**\r\n     * Get all of the unique values (in the order they first appeared) from one or more arrays\r\n     * @param {...Array} constituent An array to combine into a larger array of unique values\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var unique = function () {\r\n      if (!arguments.length) {\r\n        return [];\r\n      }\r\n  \r\n      var all = Array.prototype.concat.apply([], arguments);\r\n      for (var a = 0; a < all.length; a++) {\r\n        if (all.indexOf(all[a]) < a) {\r\n          all.splice(a, 1);\r\n          a--;\r\n        }\r\n      }\r\n      return all;\r\n    };\r\n  \r\n    /**\r\n     * Make a shallow copy of an object or array\r\n     * @param {Object|string[]} item The object/array that will be copied\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var copy = function (item) {\r\n      if (item instanceof Array) {\r\n        return item.slice();\r\n      } else {\r\n        var output = {};\r\n        for (var i in item) {\r\n          output[i] = item[i];\r\n        }\r\n        return output;\r\n      }\r\n    };\r\n  \r\n    /**\r\n     * Do a boolean intersection between an array/object and a filter array\r\n     * @param {Object|string[]} item The object/array that will be intersected with the filter\r\n     * @param {boolean|string[]} filter Specifies which properties to select from the \"item\" (or element to keep, if \"item is an array\")\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var boolInter = function (item, filter) {\r\n      var output;\r\n      if (item instanceof Array) {\r\n        output = unique(\r\n          item.filter(function (val) {\r\n            return filter.indexOf(val) > -1;\r\n          })\r\n        );\r\n      } else {\r\n        output = {};\r\n        for (var f in filter) {\r\n          if (item.hasOwnProperty(filter[f])) {\r\n            output[filter[f]] = item[filter[f]];\r\n          }\r\n        }\r\n      }\r\n      return output;\r\n    };\r\n  \r\n    /**\r\n     * Do a boolean difference between an array/object and a filter array\r\n     * @param {Object|string[]} item The object/array that will be differntiated with the filter\r\n     * @param {boolean|string[]} filter Specifies which properties to exclude from the \"item\" (or element to remove, if \"item is an array\")\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var boolDiff = function (item, filter) {\r\n      var output;\r\n      if (item instanceof Array) {\r\n        output = unique(\r\n          item.filter(function (val) {\r\n            return filter.indexOf(val) === -1;\r\n          })\r\n        );\r\n      } else {\r\n        output = {};\r\n        for (var i in item) {\r\n          output[i] = item[i];\r\n        }\r\n        for (var f in filter) {\r\n          if (output.hasOwnProperty(filter[f])) {\r\n            delete output[filter[f]];\r\n          }\r\n        }\r\n      }\r\n      return output;\r\n    };\r\n  \r\n    /**\r\n     * Determine whether we want to do a boolean intersection or difference\r\n     * @param {Object|string[]} item The object/array that will be differntiated with the filter\r\n     * @param {boolean|Array} filter Specifies which a filter behavior; if it is an array, the first value can be a boolean, indicating whether the filter array is intended for differentiation (true) or intersection (false)\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var boolFilter = function (item, filter) {\r\n      //A \"false\" filter means we return an empty copy of item\r\n      if (filter === false) {\r\n        return item instanceof Array ? [] : {};\r\n      }\r\n  \r\n      if (filter instanceof Array && filter.length) {\r\n        if (typeof filter[0] === \"boolean\") {\r\n          if (filter.length == 1 && typeof filter[0] === \"boolean\") {\r\n            //There is a filter array, but its only a sigle boolean\r\n            if (filter[0] === true) {\r\n              return copy(item);\r\n            } else {\r\n              return item instanceof Array ? [] : {};\r\n            }\r\n          } else {\r\n            //The filter operation has been set explicitly; true = difference\r\n            if (filter[0] === true) {\r\n              return boolDiff(item, filter.slice(1));\r\n            } else {\r\n              return boolInter(item, filter.slice(1));\r\n            }\r\n          }\r\n        } else {\r\n          //There is no explicit operation on the filter, meaning it defaults to an intersection\r\n          return boolInter(item, filter);\r\n        }\r\n      } else {\r\n        return copy(item);\r\n      }\r\n    };\r\n  \r\n    /**\r\n     * Ensure that a FilterList type input is converted into its shorthand array form\r\n     * @param {boolean|FilterList} filterList The FilterList, or boolean, that will converted into the shorthand form\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var toShorthand = function (filterList) {\r\n      var outputArray;\r\n      if (typeof filterList === \"boolean\") {\r\n        return filterList;\r\n      } else if (typeof filterList === \"object\" && filterList !== null) {\r\n        if (filterList instanceof Array) {\r\n          return filterList.filter(function (v, i) {\r\n            return typeof v === \"string\" || (i === 0 && v === true)\r\n              ? true\r\n              : false;\r\n          });\r\n        } else {\r\n          if (!(filterList.values instanceof Array)) {\r\n            return false;\r\n          }\r\n  \r\n          outputArray = filterList.values.filter(function (v) {\r\n            return typeof v === \"string\" ? true : false;\r\n          });\r\n  \r\n          if (!outputArray.length) {\r\n            return false;\r\n          }\r\n  \r\n          if (filterList.exclude) {\r\n            outputArray.unshift(filterList.exclude);\r\n          }\r\n          return outputArray;\r\n        }\r\n      } else if (filterList) {\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n  \r\n    /**\r\n     * Check if the supplied string value is a relative path, and convert it to an absolute one if necessary; the segment processing paths leading with \"../\" was inspired by: http://stackoverflow.com/a/14780463/2230156\r\n     * @param {string} value The value that might be a relative path, and would thus need conversion\r\n     * @param {Object} origin The origin URL from which to which non-absolute paths are relative\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var toAbsolute = function (value, origin) {\r\n      var protocol, stack, parts;\r\n      //Sometimes, we get lucky and the DOM Node we're working on already has the absolute URL as a DOM property, so we can just use that\r\n      /*if (node[name]){\r\n              //We can just grab the compiled URL directly from the DOM element - easy peasy\r\n              var sub = node[name].indexOf(value);\r\n              if (sub !== -1) {\r\n                  return node[name];\r\n              }\r\n          }*/\r\n  \r\n      //Check to make sure we don't already have an absolute path, or even a dataURI\r\n      if (value.match(/(?:^data\\:|^[\\w\\-\\+\\.]*?\\:\\/\\/|^\\/\\/)/i)) {\r\n        return value;\r\n      }\r\n  \r\n      //If we are using the root URL, start from there\r\n      if (value.charAt(0) === \"/\") {\r\n        return origin + value.substr(1);\r\n      }\r\n  \r\n      //Uh-oh, the relative path is leading with a single or double dot (\"./\" or \"../\"); things get a bit harder...\r\n      protocol =\r\n        origin.indexOf(\"://\") > -1\r\n          ? origin.substring(0, origin.indexOf(\"://\") + 3)\r\n          : \"\";\r\n      stack = (\r\n        protocol.length ? origin.substring(protocol.length) : origin\r\n      ).split(\"/\");\r\n      parts = value.split(\"/\");\r\n  \r\n      //The value after the last slash is ALWAYS considered a filename, not a directory, so always have trailing slashes on paths ending at directories!\r\n      stack.pop();\r\n  \r\n      //Cycle through the relative path, changing the stack as we go\r\n      for (var i = 0; i < parts.length; i++) {\r\n        if (parts[i] == \".\") {\r\n          continue;\r\n        }\r\n        if (parts[i] == \"..\") {\r\n          if (stack.length > 1) {\r\n            stack.pop();\r\n          }\r\n        } else {\r\n          stack.push(parts[i]);\r\n        }\r\n      }\r\n      return protocol + stack.join(\"/\");\r\n    };\r\n  \r\n    /**\r\n     * Create a copy of a node's properties, ignoring nasty things like event handles and functions\r\n     * @param {Node} node The DOM Node whose properties will be copied\r\n     * @param {Object} [opts] The options object passed down from the .toJSON() method; includes all options, even those not relevant to this function\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var copyJSON = function (node, opts) {\r\n      var copy = {};\r\n      //Copy all of the node's properties\r\n      for (var n in node) {\r\n        //Make sure this property can be accessed\r\n        try {\r\n          //accessing `selectionDirection`, `selectionStart`, or `selectionEnd` throws in WebKit-based browsers\r\n          node[n];\r\n        } catch (e) {\r\n          continue;\r\n        }\r\n        //Make sure this is an own property, and isn't a live javascript function for security reasons\r\n        if (\r\n          typeof node[n] !== \"undefined\" &&\r\n          typeof node[n] !== \"function\" &&\r\n          n.charAt(0).toLowerCase() === n.charAt(0)\r\n        ) {\r\n          //Only allowed objects are arrays\r\n          if (typeof node[n] !== \"object\" || node[n] instanceof Array) {\r\n            //If we are eliminating empty fields, make sure this value is not NULL or UNDEFINED\r\n            if (opts.cull) {\r\n              if (node[n] || node[n] === 0 || node[n] === false) {\r\n                copy[n] = node[n];\r\n              }\r\n            } else {\r\n              copy[n] = node[n];\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      copy = boolFilter(copy, opts.domProperties);\r\n      return copy;\r\n    };\r\n  \r\n    /**\r\n     * Convert the attributes property of a DOM Node to a JSON ready object.\r\n     * Also add a custom attribute \"data-selector\" to the DOM Node before converting.\r\n     * @param {Node} node The DOM Node whose attributes will be copied\r\n     * @param {Object} [opts] The options object passed down from the .toJSON() method; includes all options, even those not relevant to this function\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var attrJSON = function (node, opts) {\r\n      var attributes = {};\r\n      var attr = node.attributes;\r\n      var length = attr.length;\r\n      var absAttr;\r\n  \r\n      for (var i = 0; i < length; i++) {\r\n        attributes[attr[i].name] = attr[i].value;\r\n      }\r\n\r\n      //Author: Ruben a.k.a the GOAT\r\n      //Inserting custom attribute \"data-selector\" with the selector of the element as the value.\r\n      attributes[\"data-selector\"] = (0,_medv_finder__WEBPACK_IMPORTED_MODULE_0__.finder)(node);\r\n\r\n      attributes = opts.attributes\r\n        ? boolFilter(attributes, opts.attributes)\r\n        : null;\r\n  \r\n      //Add the attributes object, converting any specified absolute paths along the way\r\n      absAttr = boolFilter(attributes, opts.absolutePaths);\r\n      for (var i in absAttr) {\r\n        attributes[i] = toAbsolute(absAttr[i], opts.absoluteBase);\r\n      }\r\n  \r\n      return attributes;\r\n    };\r\n  \r\n    /**\r\n     * Grab a DOM Node's computed style\r\n     * @param {Node} node The DOM Node whose computed style will be calculated\r\n     * @param {Object} [opts] The options object passed down from the .toJSON() method; includes all options, even those not relevant to this function\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var styleJSON = function (node, opts) {\r\n      //Grab the computed style\r\n      var style,\r\n        css = {};\r\n      if (opts.computedStyle && node.style instanceof CSSStyleDeclaration) {\r\n        style = win.getComputedStyle(node);\r\n      } else {\r\n        return null;\r\n      }\r\n  \r\n      //Get the relevant properties from the computed style\r\n      for (var k in style) {\r\n        if (\r\n          k !== \"cssText\" &&\r\n          !k.match(/\\d/) &&\r\n          typeof style[k] === \"string\" &&\r\n          style[k].length\r\n        ) {\r\n          //css.push(k+ ': ' +style[k]+ ';');\r\n          css[k] = style[k];\r\n        }\r\n      }\r\n  \r\n      //Filter the style object\r\n      return opts.computedStyle instanceof Array\r\n        ? boolFilter(css, opts.computedStyle)\r\n        : css;\r\n    };\r\n  \r\n    /**\r\n     * Convert a single DOM Node into a simple object\r\n     * @param {Node} node The DOM Node that will be converted\r\n     * @param {Object} [opts] The options object passed down from the .toJSON() method; includes all options, even those not relevant to this function\r\n     * @private\r\n     * @ignore\r\n     */\r\n    var toJSON = function (node, opts, depth) {\r\n      var style,\r\n        kids,\r\n        kidCount,\r\n        thisChild,\r\n        children,\r\n        copy = copyJSON(node, opts); // Node, Ã¼ber den iteriert wird \r\n  \r\n      //Per default, some tags are not allowed\r\n      if (node.nodeType === 1) {\r\n        if (!opts.allowDangerousElements) {\r\n          for (var b in banned) {\r\n            if (node.tagName.toLowerCase() === banned[b]) {\r\n              return null;\r\n            }\r\n          }\r\n        }\r\n      } else if (node.nodeType === 3 && !node.nodeValue.trim()) {\r\n        //Ignore empty buffer text nodes\r\n        return null;\r\n      }\r\n  \r\n      //Copy all attributes and styles, if allowed\r\n      if (opts.attributes && node.attributes) {\r\n        copy.attributes = attrJSON(node, opts);\r\n      }\r\n      if (opts.computedStyle && (style = styleJSON(node, opts))) {\r\n        copy.style = style;\r\n      }\r\n  \r\n      //Should we continue iterating?\r\n      if (\r\n        opts.deep === true ||\r\n        (typeof opts.deep === \"number\" && opts.deep > depth)\r\n      ) {\r\n        //We should!\r\n        children = [];\r\n        kids = opts.htmlOnly ? node.children : node.childNodes;\r\n        kidCount = kids.length;\r\n        for (var c = 0; c < kidCount; c++) {\r\n          thisChild = toJSON(kids[c], opts, depth + 1);\r\n          if (thisChild) {\r\n            children.push(thisChild);\r\n          }\r\n        }\r\n  \r\n        //Append the children in the appropriate place\r\n        copy.childNodes = children;\r\n      }\r\n      return copy;\r\n    };\r\n  \r\n    /**\r\n     * Take a DOM node and convert it to simple object literal (or JSON string) with no circular references and no functions or events\r\n     * @param {Node} node The actual DOM Node which will be the starting point for parsing the DOM Tree\r\n     * @param {Object} [opts] A list of all method options\r\n     * @param {boolean} [opts.allowDangerousElements=`false`] Use `true` to parse the potentially dangerous elements `<link>` and `<script>`\r\n     * @param {boolean|FilterList} [opts.absolutePaths=`'action', 'data', 'href', 'src'`] Only relevant if `opts.attributes` is not `false`; use `true` to convert all relative paths found in attribute values to absolute paths, or specify a `FilterList` of keys to boolean search\r\n     * @param {boolean|FilterList} [opts.attributes=`true`] Use `true` to copy all attribute key-value pairs, or specify a `FilterList` of keys to boolean search\r\n     * @param {boolean|FilterList} [opts.computedStyle=`false`] Use `true` to parse the results of \"window.getComputedStyle()\" on every node (specify a `FilterList` of CSS properties to be included via boolean search); this operation is VERY costly performance-wise!\r\n     * @param {boolean} [opts.cull=`false`] Use `true` to ignore empty element properties\r\n     * @param {boolean|number} [opts.deep=`true`] Use `true` to iterate and copy all childNodes, or an INTEGER indicating how many levels down the DOM tree to iterate\r\n     * @param {boolean|FilterList} [opts.domProperties=true] 'false' means only 'tagName', 'nodeType', and 'nodeValue' properties will be copied, while a `FilterList` can specify DOM properties to include or exclude in the output (except for ones which serialize the DOM Node, which are handled separately by `opts.serialProperties`)\r\n     * @param {boolean} [opts.htmlOnly=`false`] Use `true` to only iterate through childNodes where nodeType = 1 (aka, instances of HTMLElement); irrelevant if `opts.deep` is `true`\r\n     * @param {boolean} [opts.metadata=`false`] Output a special object of the domJSON class, which includes metadata about this operation\r\n     * @todo {boolean|FilterList} [opts.parse=`false`] a `FilterList` of properties that are DOM nodes, but will still be copied **PLANNED**\r\n     * @param {boolean|FilterList} [opts.serialProperties=`true`] Use `true` to ignore the properties that store a serialized version of this DOM Node (ex: outerHTML, innerText, etc), or specify a `FilterList` of serial properties (no boolean search!)\r\n     * @param {boolean} [opts.stringify=`false`] Output a JSON string, or just a JSON-ready javascript object?\r\n     * @return {Object|string} A JSON-friendly object, or JSON string, of the DOM node -> JSON conversion output\r\n     * @method\r\n     * @memberof domJSON\r\n     */\r\n    domJSON.toJSON = function (node, opts) {\r\n      var copy,\r\n        keys = [],\r\n        options = {},\r\n        output = {};\r\n      var timer = new Date().getTime();\r\n      var requiring = required.slice();\r\n      var ignoring = ignored.slice();\r\n  \r\n      //Update the default options w/ the user's custom settings\r\n      options = extend({}, defaultsForToJSON, opts);\r\n  \r\n      //Convert all options that accept FilterList type inputs into the shorthand notation\r\n      options.absolutePaths = toShorthand(options.absolutePaths);\r\n      options.attributes = toShorthand(options.attributes);\r\n      options.computedStyle = toShorthand(options.computedStyle);\r\n      options.domProperties = toShorthand(options.domProperties);\r\n      options.serialProperties = toShorthand(options.serialProperties);\r\n  \r\n      //Make sure there is a base URL for absolute path conversions\r\n      //options.absoluteBase = win.location.origin + \"/\";\r\n  \r\n      //Make lists of which DOM properties to skip and/or which are absolutely necessary\r\n      if (options.serialProperties !== true) {\r\n        if (\r\n          options.serialProperties instanceof Array &&\r\n          options.serialProperties.length\r\n        ) {\r\n          if (options.serialProperties[0] === true) {\r\n            ignoring = ignoring.concat(\r\n              boolDiff(serials, options.serialProperties)\r\n            );\r\n          } else {\r\n            ignoring = ignoring.concat(\r\n              boolInter(serials, options.serialProperties)\r\n            );\r\n          }\r\n        } else {\r\n          ignoring = ignoring.concat(serials);\r\n        }\r\n      }\r\n      if (options.domProperties instanceof Array) {\r\n        if (options.domProperties[0] === true) {\r\n          options.domProperties = boolDiff(\r\n            unique(options.domProperties, ignoring),\r\n            requiring\r\n          );\r\n        } else {\r\n          options.domProperties = boolDiff(\r\n            unique(options.domProperties, requiring),\r\n            ignoring\r\n          );\r\n        }\r\n      } else {\r\n        if (options.domProperties === false) {\r\n          options.domProperties = requiring;\r\n        } else {\r\n          options.domProperties = [true].concat(ignoring);\r\n        }\r\n      }\r\n  \r\n      //Transform the node into an object literal\r\n      copy = toJSON(node, options, 0);\r\n  \r\n      //Wrap our copy object in a nice object of its own to save some metadata\r\n      output = copy;\r\n      \r\n  \r\n      //If opts.stringify is true, turn the output object into a JSON string\r\n      if (options.stringify) {\r\n        return JSON.stringify(output);\r\n      }\r\n      return output;\r\n    };\r\n  \r\n    /* test-code */\r\n    //The code below is only included for private API testing, and needs to be removed in distributed builds\r\n    domJSON.__extend = extend;\r\n    domJSON.__unique = unique;\r\n    domJSON.__copy = copy;\r\n    domJSON.__boolFilter = boolFilter;\r\n    domJSON.__boolInter = boolInter;\r\n    domJSON.__boolDiff = boolDiff;\r\n    domJSON.__toShorthand = toShorthand;\r\n    /* end-test-code */\r\n  \r\n    return domJSON;\r\n  }\r\n  \r\n  //Load the library\r\n  (function (root) {\r\n    /* istanbul ignore next */\r\n    // eslint-disable-next-line no-undef\r\n    if (typeof define === \"function\" && __webpack_require__.amdO) {\r\n      //AMD\r\n      // eslint-disable-next-line no-undef\r\n      define(function () {\r\n        return createDomJSON(root);\r\n      });\r\n    } else if (typeof exports !== \"undefined\") {\r\n      //CommonJS/node.js\r\n      var domJSON = createDomJSON(root);\r\n      if ( true && module.exports) {\r\n        module.exports = domJSON;\r\n      }\r\n      exports = domJSON;\r\n    } else {\r\n      //Browser global\r\n      window.domJSON = createDomJSON(root);\r\n    }\r\n  })(undefined);\r\n\r\n  module.exports = createDomJSON;\n\n//# sourceURL=webpack:///./src/lib/truncate/domJSON.js?");

/***/ }),

/***/ "../../../node_modules/@medv/finder/finder.js":
/*!****************************************************!*\
  !*** ../../../node_modules/@medv/finder/finder.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"finder\": () => (/* binding */ finder)\n/* harmony export */ });\n// License: MIT\n// Author: Anton Medvedev <anton@medv.io>\n// Source: https://github.com/antonmedv/finder\nlet config;\nlet rootDocument;\nlet start;\nfunction finder(input, options) {\n    start = new Date();\n    if (input.nodeType !== Node.ELEMENT_NODE) {\n        throw new Error(`Can't generate CSS selector for non-element node type.`);\n    }\n    if ('html' === input.tagName.toLowerCase()) {\n        return 'html';\n    }\n    const defaults = {\n        root: document.body,\n        idName: (name) => true,\n        className: (name) => true,\n        tagName: (name) => true,\n        attr: (name, value) => false,\n        seedMinLength: 1,\n        optimizedMinLength: 2,\n        threshold: 1000,\n        maxNumberOfTries: 10000,\n        timeoutMs: undefined,\n    };\n    config = { ...defaults, ...options };\n    rootDocument = findRootDocument(config.root, defaults);\n    let path = bottomUpSearch(input, 'all', () => bottomUpSearch(input, 'two', () => bottomUpSearch(input, 'one', () => bottomUpSearch(input, 'none'))));\n    if (path) {\n        const optimized = sort(optimize(path, input));\n        if (optimized.length > 0) {\n            path = optimized[0];\n        }\n        return selector(path);\n    }\n    else {\n        throw new Error(`Selector was not found.`);\n    }\n}\nfunction findRootDocument(rootNode, defaults) {\n    if (rootNode.nodeType === Node.DOCUMENT_NODE) {\n        return rootNode;\n    }\n    if (rootNode === defaults.root) {\n        return rootNode.ownerDocument;\n    }\n    return rootNode;\n}\nfunction bottomUpSearch(input, limit, fallback) {\n    let path = null;\n    let stack = [];\n    let current = input;\n    let i = 0;\n    while (current) {\n        const elapsedTime = new Date().getTime() - start.getTime();\n        if (config.timeoutMs !== undefined && elapsedTime > config.timeoutMs) {\n            throw new Error(`Timeout: Can't find a unique selector after ${elapsedTime}ms`);\n        }\n        let level = maybe(id(current)) ||\n            maybe(...attr(current)) ||\n            maybe(...classNames(current)) ||\n            maybe(tagName(current)) || [any()];\n        const nth = index(current);\n        if (limit == 'all') {\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));\n            }\n        }\n        else if (limit == 'two') {\n            level = level.slice(0, 1);\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map((node) => nthChild(node, nth)));\n            }\n        }\n        else if (limit == 'one') {\n            const [node] = (level = level.slice(0, 1));\n            if (nth && dispensableNth(node)) {\n                level = [nthChild(node, nth)];\n            }\n        }\n        else if (limit == 'none') {\n            level = [any()];\n            if (nth) {\n                level = [nthChild(level[0], nth)];\n            }\n        }\n        for (let node of level) {\n            node.level = i;\n        }\n        stack.push(level);\n        if (stack.length >= config.seedMinLength) {\n            path = findUniquePath(stack, fallback);\n            if (path) {\n                break;\n            }\n        }\n        current = current.parentElement;\n        i++;\n    }\n    if (!path) {\n        path = findUniquePath(stack, fallback);\n    }\n    if (!path && fallback) {\n        return fallback();\n    }\n    return path;\n}\nfunction findUniquePath(stack, fallback) {\n    const paths = sort(combinations(stack));\n    if (paths.length > config.threshold) {\n        return fallback ? fallback() : null;\n    }\n    for (let candidate of paths) {\n        if (unique(candidate)) {\n            return candidate;\n        }\n    }\n    return null;\n}\nfunction selector(path) {\n    let node = path[0];\n    let query = node.name;\n    for (let i = 1; i < path.length; i++) {\n        const level = path[i].level || 0;\n        if (node.level === level - 1) {\n            query = `${path[i].name} > ${query}`;\n        }\n        else {\n            query = `${path[i].name} ${query}`;\n        }\n        node = path[i];\n    }\n    return query;\n}\nfunction penalty(path) {\n    return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);\n}\nfunction unique(path) {\n    const css = selector(path);\n    switch (rootDocument.querySelectorAll(css).length) {\n        case 0:\n            throw new Error(`Can't select any node with this selector: ${css}`);\n        case 1:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction id(input) {\n    const elementId = input.getAttribute('id');\n    if (elementId && config.idName(elementId)) {\n        return {\n            name: '#' + CSS.escape(elementId),\n            penalty: 0,\n        };\n    }\n    return null;\n}\nfunction attr(input) {\n    const attrs = Array.from(input.attributes).filter((attr) => config.attr(attr.name, attr.value));\n    return attrs.map((attr) => ({\n        name: `[${CSS.escape(attr.name)}=\"${CSS.escape(attr.value)}\"]`,\n        penalty: 0.5,\n    }));\n}\nfunction classNames(input) {\n    const names = Array.from(input.classList).filter(config.className);\n    return names.map((name) => ({\n        name: '.' + CSS.escape(name),\n        penalty: 1,\n    }));\n}\nfunction tagName(input) {\n    const name = input.tagName.toLowerCase();\n    if (config.tagName(name)) {\n        return {\n            name,\n            penalty: 2,\n        };\n    }\n    return null;\n}\nfunction any() {\n    return {\n        name: '*',\n        penalty: 3,\n    };\n}\nfunction index(input) {\n    const parent = input.parentNode;\n    if (!parent) {\n        return null;\n    }\n    let child = parent.firstChild;\n    if (!child) {\n        return null;\n    }\n    let i = 0;\n    while (child) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            i++;\n        }\n        if (child === input) {\n            break;\n        }\n        child = child.nextSibling;\n    }\n    return i;\n}\nfunction nthChild(node, i) {\n    return {\n        name: node.name + `:nth-child(${i})`,\n        penalty: node.penalty + 1,\n    };\n}\nfunction dispensableNth(node) {\n    return node.name !== 'html' && !node.name.startsWith('#');\n}\nfunction maybe(...level) {\n    const list = level.filter(notEmpty);\n    if (list.length > 0) {\n        return list;\n    }\n    return null;\n}\nfunction notEmpty(value) {\n    return value !== null && value !== undefined;\n}\nfunction* combinations(stack, path = []) {\n    if (stack.length > 0) {\n        for (let node of stack[0]) {\n            yield* combinations(stack.slice(1, stack.length), path.concat(node));\n        }\n    }\n    else {\n        yield path;\n    }\n}\nfunction sort(paths) {\n    return [...paths].sort((a, b) => penalty(a) - penalty(b));\n}\nfunction* optimize(path, input, scope = {\n    counter: 0,\n    visited: new Map(),\n}) {\n    if (path.length > 2 && path.length > config.optimizedMinLength) {\n        for (let i = 1; i < path.length - 1; i++) {\n            if (scope.counter > config.maxNumberOfTries) {\n                return; // Okay At least I tried!\n            }\n            scope.counter += 1;\n            const newPath = [...path];\n            newPath.splice(i, 1);\n            const newPathKey = selector(newPath);\n            if (scope.visited.has(newPathKey)) {\n                return;\n            }\n            if (unique(newPath) && same(newPath, input)) {\n                yield newPath;\n                scope.visited.set(newPathKey, true);\n                yield* optimize(newPath, input, scope);\n            }\n        }\n    }\n}\nfunction same(path, input) {\n    return rootDocument.querySelector(selector(path)) === input;\n}\n\n\n//# sourceURL=webpack:///../../../node_modules/@medv/finder/finder.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/lib/truncate/filter.ts");
/******/ 	
/******/ })()
;